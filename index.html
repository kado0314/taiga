<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>音声ファイル文字起こしアプリ</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    
    <script src="https://unpkg.com/docx@7.8.2/build/index.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.7/pdfmake.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.7/vfs_fonts.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', 'Noto Sans JP', sans-serif; }
        #transcript { min-height: 400px; }
        .lucide { width: 20px; height: 20px; stroke-width: 2; }
        input[type="file"] { display: none; }
        #uploadLabel:disabled, #uploadLabel[disabled] {
            opacity: 0.5; cursor: not-allowed; background-color: #9ca3af;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-900 antialiased">

    <div class="container mx-auto max-w-4xl p-4 sm:p-8">
        <header class="mb-8 text-center">
            <h1 class="text-3xl sm:text-4xl font-bold text-gray-800">音声ファイル文字起こしアプリ</h1>
            <p class="text-lg text-gray-600 mt-2">ブラウザだけで動作します。データは外部に送信されません。</p>
        </header>

        <main class="bg-white p-6 sm:p-8 rounded-2xl shadow-lg">

            <div class="flex flex-col sm:flex-row items-center justify-between gap-4 mb-6">
                <input type="file" id="audioUpload" accept="audio/*">
                <label for="audioUpload" id="uploadLabel" class="w-full sm:w-auto flex items-center justify-center gap-2 bg-blue-600 text-white px-6 py-3 rounded-lg font-semibold shadow-md hover:bg-blue-700 transition-all duration-300 cursor-pointer">
                    <i data-lucide="upload" class="lucide"></i>
                    <span>音声ファイルを選択</span>
                </label>
                
                <div id="status" class="text-gray-600 font-medium bg-gray-100 px-4 py-2 rounded-lg text-sm sm:text-base">
                    準備中...
                </div>
            </div>

            <div class="mb-6">
                <label for="transcript" class="block text-sm font-medium text-gray-700 mb-2">認識結果</label>
                <textarea id="transcript" class="w-full p-4 border border-gray-300 rounded-lg shadow-inner focus:outline-none focus:ring-2 focus:ring-blue-500 resize-y" placeholder="ここに文字起こし結果が表示されます..."></textarea>
            </div>

            <div class="flex flex-col sm:flex-row gap-4">
                <button id="exportWord" class="flex-1 flex items-center justify-center gap-2 bg-green-600 text-white px-6 py-3 rounded-lg font-semibold shadow-md hover:bg-green-700 transition-all">
                    <i data-lucide="file-text" class="lucide"></i>
                    Word (.docx) で保存
                </button>
                <button id="exportPdf" class="flex-1 flex items-center justify-center gap-2 bg-red-600 text-white px-6 py-3 rounded-lg font-semibold shadow-md hover:bg-red-700 transition-all opacity-80">
                    <i data-lucide="file-type-2" class="lucide"></i>
                    PDF (日本語不可)
                </button>
            </div>

        </main>

        <div id="messageBox" class="fixed bottom-4 right-4 p-4 rounded-lg shadow-xl text-white transition-opacity duration-500 opacity-0 max-w-sm hidden"></div>
    </div>

    <script type="module">
        // ---------------------------------------------------------
        // 1. 初期化とライブラリ読み込み
        // ---------------------------------------------------------
        let pipeline;
        const statusEl = document.getElementById('status');
        const transcriptEl = document.getElementById('transcript');
        const exportWordButton = document.getElementById('exportWord');
        const exportPdfButton = document.getElementById('exportPdf');
        const messageBox = document.getElementById('messageBox');
        const audioUpload = document.getElementById('audioUpload');
        const uploadLabel = document.getElementById('uploadLabel');
        let recognizer;

        // Transformers.js (v2.17.1) の読み込み
        try {
            const transformers = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1');
            pipeline = transformers.pipeline;
        } catch (err) {
            console.error('Transformers load failed:', err);
            statusEl.textContent = 'ライブラリ読込エラー';
            alert('AIライブラリの読み込みに失敗しました。ページを更新してください。');
        }

        // アイコン表示
        if (typeof lucide !== 'undefined') lucide.createIcons();

        // ---------------------------------------------------------
        // 2. 音声認識ロジック
        // ---------------------------------------------------------
        async function initializeRecognizer() {
            if (!pipeline) return;
            try {
                statusEl.textContent = 'モデルDL中... (初回のみ時間がかかります)';
                uploadLabel.disabled = true;

                // Whisperモデルのロード
                recognizer = await pipeline('automatic-speech-recognition', 'Xenova/whisper-small', {
                    progress_callback: (progress) => {
                        if (progress.status === 'progress') {
                            const p = progress.progress ? (progress.progress * 100).toFixed(0) : 0;
                            statusEl.textContent = `モデル準備中... ${p}%`;
                        }
                    }
                });
                
                statusEl.textContent = '音声ファイルを選択してください';
                uploadLabel.disabled = false;
            } catch (err) {
                console.error(err);
                statusEl.textContent = '初期化エラー';
                showMessage('モデルの読み込みに失敗しました。', 'error');
            }
        }

        async function resampleAudio(audioBuffer, targetSampleRate = 16000) {
            const offlineCtx = new OfflineAudioContext(1, audioBuffer.duration * targetSampleRate, targetSampleRate);
            const source = offlineCtx.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(offlineCtx.destination);
            source.start();
            const renderedBuffer = await offlineCtx.startRendering();
            return renderedBuffer.getChannelData(0);
        }

        audioUpload.addEventListener('change', (event) => {
            if (!recognizer) {
                showMessage('AIの準備が完了していません。', 'warning');
                return;
            }
            const file = event.target.files[0];
            if (!file) return;

            statusEl.textContent = 'ファイルを解析中...';
            transcriptEl.value = '';
            uploadLabel.disabled = true;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    const audioBuffer = await audioCtx.decodeAudioData(e.target.result);
                    const audioData = await resampleAudio(audioBuffer);

                    statusEl.textContent = '文字起こし中... (待機中)';
                    
                    const output = await recognizer(audioData, {
                        language: 'ja',
                        task: 'transcribe',
                    });

                    transcriptEl.value = output.text;
                    statusEl.textContent = '完了しました';
                    showMessage('文字起こし完了！', 'success');

                } catch (err) {
                    console.error(err);
                    statusEl.textContent = 'エラー発生';
                    showMessage('処理中にエラーが発生しました。', 'error');
                } finally {
                    uploadLabel.disabled = false;
                    audioUpload.value = null;
                }
            };
            reader.readAsArrayBuffer(file);
        });

        // ---------------------------------------------------------
        // 3. Wordエクスポート機能 (修正版)
        // ---------------------------------------------------------
        exportWordButton.addEventListener('click', () => {
            const text = transcriptEl.value;
            if (!text.trim()) {
                showMessage('テキストが空です。', 'warning');
                return;
            }

            // docxライブラリの取得
            const docx = window.docx;
            if (!docx) {
                showMessage('Word機能の読み込みに失敗しました。', 'error');
                return;
            }

            const { Document, Packer, Paragraph, TextRun } = docx;

            // テキストを段落に分割
            const paragraphs = text.split('\n').map(line => {
                return new Paragraph({
                    children: [new TextRun(line)],
                    spacing: { after: 200 }
                });
            });

            const doc = new Document({
                sections: [{ properties: {}, children: paragraphs }]
            });

            Packer.toBlob(doc).then(blob => {
                saveAs(blob, "文字起こし結果.docx");
                showMessage('Wordファイルを保存しました。', 'success');
            }).catch(err => {
                console.error(err);
                showMessage('保存に失敗しました。', 'error');
            });
        });

        // ---------------------------------------------------------
        // 4. PDFエクスポート機能 (制限版)
        // ---------------------------------------------------------
        exportPdfButton.addEventListener('click', () => {
            const text = transcriptEl.value;
            if (!text.trim()) {
                showMessage('テキストが空です。', 'warning');
                return;
            }

            // 警告を表示
            alert('【注意】\n現在、PDF出力では日本語フォントが含まれていないため、日本語部分は空白になります。\n\n日本語の保存には隣の「Wordで保存」ボタンを使用してください。');

            // それでもダウンロードする場合（英語用）
            const docDefinition = {
                content: [{ text: text, fontSize: 11, lineHeight: 1.4 }]
            };
            
            try {
                pdfMake.createPdf(docDefinition).download('transcription_log.pdf');
            } catch (err) {
                console.error(err);
            }
        });

        // ---------------------------------------------------------
        // ユーティリティ
        // ---------------------------------------------------------
        let messageTimer;
        function showMessage(msg, type = 'info') {
            if (messageTimer) clearTimeout(messageTimer);
            messageBox.textContent = msg;
            messageBox.className = 'fixed bottom-4 right-4 p-4 rounded-lg shadow-xl text-white transition-opacity duration-500 max-w-sm';
            
            if (type === 'success') messageBox.classList.add('bg-green-600');
            else if (type === 'error') messageBox.classList.add('bg-red-600');
            else if (type === 'warning') messageBox.classList.add('bg-yellow-600');
            else messageBox.classList.add('bg-blue-600');

            messageBox.classList.remove('hidden', 'opacity-0');
            messageBox.classList.add('opacity-100');

            messageTimer = setTimeout(() => {
                messageBox.classList.remove('opacity-100');
                setTimeout(() => messageBox.classList.add('hidden'), 500);
            }, 3000);
        }

        // アプリ起動
        initializeRecognizer();

    </script>
</body>
</html>
